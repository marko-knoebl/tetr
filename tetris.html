<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Tetris</title>
    <script src="https://unpkg.com/react@15.3.2/dist/react.js"></script>
    <script src="https://unpkg.com/react-dom@15.3.2/dist/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.17.0/babel.min.js"></script>
  </head>
  <body>
    <div id="main"></div>
    <script type="text/babel">
      
      // size of one block in px
      var blockSize = 20;
      // field size in blocks
      var fieldSize = [10, 10];
      var interval = 600;

      var shapeTemplates = [
        {
          blocks: [[4, 0], [5, 0], [4, 1], [5, 1]],
          center: [4.5, 0.5]
        },
        {
          blocks: [[4, 0], [4, 1], [4, 2], [4, 3]],
          center: [4, 1]
        },
        {
          blocks: [[4, 0], [4, 1], [4, 2], [5, 2]],
          center: [4, 1]
        },
        {
          blocks: [[5, 0], [5, 1], [5, 2], [4, 2]],
          center: [4, 1]
        }
      ];
      
      var existingBlocks = [];

      var currentShape = getRandomShape();
      
      function getRandomShape() {
        var shape = shapeTemplates[Math.floor(Math.random() * shapeTemplates.length)];
        var newShape = {blocks: [], center: shape.center.slice()};
        shape.blocks.forEach(function(block) {newShape.blocks.push(block);});
        return newShape;
      }
      
      function render() {
        ReactDOM.render(
          <div>
            {currentShape.blocks.map(createBlock)}
            {existingBlocks.map(createBlock)}
          </div>,
          document.querySelector('#main')
        );
      }
      
      function createBlock(position) {
        // create a div representing a block at a specific position
        return <div style={ {backgroundColor: 'red', position: 'absolute', width: blockSize, height: blockSize, left: blockSize * position[0], top: blockSize * position[1]} }></div>
      }

      function moveShape(shape, direction) {
        // return a copy of the shape moved in a specific direction
        var movedShape = {
          blocks: [],
          center: shape.center
        }
        shape.blocks.forEach(function(block) {
          block = block.slice();
          if (direction === 'r') {
            block[0] ++;
          } else if (direction == 'l') {
            block[0] --;
          } else if (direction == 'u') {
            block[1] --;
          } else if (direction == 'd') {
            block[1] ++;
          } else {
            throw 'invalid direction';
          }
          movedShape.blocks.push(block);
        });
        if (direction === 'r') {
          movedShape.center[0] ++;
        } else if (direction === 'l') {
          movedShape.center[0] --;
        } else if (direction === 'u') {
          movedShape.center[1] --;
        } else if (direction === 'd') {
          movedShape.center[1] ++;
        } else {
          throw 'invalid direction';
        }
        return movedShape;
      }

      function rotateShape(shape) {
        // TODO: this does not work properly
        // return a copy of the shape rotated 90Â° clockwise
        var center = shape.center;
        var movedBlocks = [];
        shape.blocks.forEach(function(block) {
          var newBlock = [-(block[1]-center[1])+center[0], block[0]-center[0]+center[1]];
          movedBlocks.push(newBlock);
        });
        return {center: center, blocks: movedBlocks};
      }

      setInterval(
        // move active shape downwards every x ms
        function() {
          var nextShape = moveShape(currentShape, 'd');
          if (canMoveTo(nextShape)) {
            currentShape = moveShape(currentShape, 'd');
          } else {
            // shape is hitting bottom or another shape
            // create a new shape instead
            existingBlocks = existingBlocks.concat(currentShape.blocks);
            currentShape = getRandomShape();
          }
          render();
        },
        interval
      );

      function canMoveTo(shape) {
        // check if a shape can move to a certain position
        // by moving left or right, down or rotating
        return isAboveBottom(shape.blocks) && isInsideArea(shape.blocks) && !overlapsExistingBlocks(shape.blocks);
      }

      function isAboveBottom(shape) {
        if (shape[3][1] >= fieldSize[1]) {
          return false;
        }
        return true;
      }

      function overlapsExistingBlocks(shape) {
        // check if the shape overlaps with existing blocks
        for (var i in existingBlocks) {
          for (var j in shape) {
            if (existingBlocks[i][0] === shape[j][0] && existingBlocks[i][1] === shape[j][1]) {
              return true;
            }
          }
        }
        return false;
      }

      function isInsideArea(shape) {
        var inside = true
        shape.forEach(function(block) {
          if (block[0] < 0 || block[0] > fieldSize[0]-1) {
            inside = false;
          }
        });
        return inside;
      }

      document.querySelector('body').addEventListener('keydown', function(event) {
        if (event.keyCode === 37 || event.keyCode === 39 || event.keyCode === 40) {
          var direction = {37: 'l', 39: 'r', 40: 'd'}[event.keyCode];
          var nextShape = moveShape(currentShape, direction);
          if (canMoveTo(nextShape)) {
            currentShape = nextShape;
            render();
          }
        } else if (event.keyCode === 38) {
          var nextShape = rotateShape(currentShape);
          if (canMoveTo(nextShape)) {
            currentShape = nextShape;
            render();
          }
        }
      });
      
      render();
    </script>
  </body>
</html>
