<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Tetris</title>
    <script src="https://unpkg.com/react@15.3.2/dist/react.js"></script>
    <script src="https://unpkg.com/react-dom@15.3.2/dist/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.17.0/babel.min.js"></script>
  </head>
  <body>
    <div id="main"></div>
    <script src="shape.js"></script>
    <script type="text/babel">
      
      // size of one block in px
      var blockSize = 20;
      // field size in blocks
      var fieldSize = [10, 20];
      var interval = 600;

      var existingBlocks = [];

      var currentShape = Shape.getRandom() //getRandomShape();

      function render() {
        ReactDOM.render(
          <div style={ {border: "1px solid #202020", width: blockSize*fieldSize[0], height: blockSize*fieldSize[1], position: 'relative'} }>
            {createDivShape(currentShape)}
            {existingBlocks.map(createDivBlock)}
          </div>,
          document.querySelector('#main')
        );
      }
      
      /**
       * create a tetris shape consisting of divs
       */
      function createDivShape(shape) {
        return shape.blocks.map(createDivBlock);
      }

      /**
       * create a div representing a block at a specific position
       */
      function createDivBlock(block) {
        return <div style={ {backgroundColor: block.color, position: 'absolute', width: blockSize, height: blockSize, left: blockSize * block.position[0], top: blockSize * block.position[1]} }></div>
      }

      setInterval(
        // move active shape downwards every x ms
        function() {
          var nextShape = currentShape.moved('d');
          if (canMoveTo(nextShape)) {
            currentShape = nextShape;
          } else {
            // shape is hitting bottom or another shape
            // create a new shape instead
            existingBlocks = existingBlocks.concat(currentShape.blocks);
            existingBlocks = clearFullRows(existingBlocks, fieldSize);
            currentShape = Shape.getRandom();
            if (!canMoveTo(currentShape)) {
              alert('Game over!');
            }
          }
          render();
        },
        interval
      );

      /**
       * Check if a shape can move to a certain position
       * (i.e. the position is not occupied)
       */
      function canMoveTo(shape) {
        return shape.isInsideField(fieldSize) && !shape.overlapsAny(existingBlocks);
      }

      // FIXME: this mutates the input
      function clearFullRows(existingBlocks, fieldSize) {
        // removes complete rows from the model
        var counts = [];
        for (var i = 0; i < fieldSize[1]; i ++) {
          counts.push(0);
        }
        existingBlocks.forEach(function(block) {
          counts[block.position[1]] ++;
        });
        for (var i = 0; i < fieldSize[1]; i ++) {
          if (counts[i] === fieldSize[0]) {
            // there's a full row
            var newExistingBlocks = []
            // copy all but the full row
            existingBlocks.forEach(function(block, index) {
              if (block.position[1] !== i) {
                newExistingBlocks.push(block);
              }
            });
            // move rows above full row further down
            newExistingBlocks.forEach(function(block) {
              if (block.position[1] < i) {
                block.position[1] ++;
              }
            });
            // overwrite the original
            existingBlocks = newExistingBlocks;
          }
        }
        return existingBlocks;
      }

      document.querySelector('body').addEventListener('keydown', function(event) {
        if (event.keyCode === 37 || event.keyCode === 39 || event.keyCode === 40) {
          var direction = {37: 'l', 39: 'r', 40: 'd'}[event.keyCode];
          var nextShape = currentShape.moved(direction);//moveShape(currentShape, direction);
          if (canMoveTo(nextShape)) {
            currentShape = nextShape;
            render();
          }
        } else if (event.keyCode === 38) {
          var nextShape = currentShape.rotated();
          if (canMoveTo(nextShape)) {
            currentShape = nextShape;
            render();
          }
        }
      });
      
      render();
    </script>
  </body>
</html>
